# S3 Vectors

<!--BEGIN STABILITY BANNER-->

---

![Stability: Experimental](https://img.shields.io/badge/stability-Experimental-important.svg?style=for-the-badge)

> All classes are under active development and subject to non-backward compatible changes or removal in any
> future version. These are not subject to the [Semantic Versioning](https://semver.org/) model.
> This means that while you may use them, you may need to update your source code when upgrading to a newer version of this package.

---

<!--END STABILITY BANNER-->

| **Language**                                                                                   | **Package**                             |
| :--------------------------------------------------------------------------------------------- | --------------------------------------- |
| ![Typescript Logo](https://docs.aws.amazon.com/cdk/api/latest/img/typescript32.png) TypeScript | `@cdklabs/generative-ai-cdk-constructs` |
| ![Python Logo](https://docs.aws.amazon.com/cdk/api/latest/img/python32.png) Python             | `cdklabs.generative_ai_cdk_constructs`  |
| ![.Net](https://docs.aws.amazon.com/cdk/api/latest/img/dotnet32.png) .Net                   | `CdkLabs.GenerativeAICdkConstructs`|
| ![Go](https://docs.aws.amazon.com/cdk/api/latest/img/go32.png) Go                   | `github.com/cdklabs/generative-ai-cdk-constructs-go/generative-ai-cdk-constructs`|

Amazon S3 Vectors delivers purpose-built, cost-optimized vector storage for your semantic search and AI applications. With Amazon S3 level elasticity and durability for storing vector datasets with sub-second query performance, S3 Vectors is ideal for applications that need to build and grow vector indexes. You get a dedicated set of API operations to store, access, and perform similarity queries on vector data without provisioning any infrastructure. S3 Vectors consists of several key components that work together:

- Vector buckets – A new bucket type that's purpose-built to store and query vectors.

- Vector indexes – Within a vector bucket, you can organize your vector data within vector indexes. You perform similarity queries on your vector data within vector indexes.

- Vectors – You store vectors in your vector index. For similarity search and AI applications, vectors are created as vector embeddings which are numerical representations that preserve semantic relationships between content (such as text, images, or audio) so similar items are positioned closer together. S3 Vectors can perform similarity searches based on semantic meaning rather than exact matching through comparing how close vectors are to each other mathematically. When adding vector data to a vector index, you can also attach metadata for future filtering queries based on a set of conditions (for example, timestamps, categories, and user preferences).

This construct library provides L2 constructs to manage S3 vectors resources.

## Table of contents

- [Vector Bucket](#vector-bucket)
- [Vector Index](#vector-index)
- [Vector Bucket Policy](#vector-bucket-policy)

## Vector bucket

Vector buckets are a type of Amazon S3 bucket designed specifically for storing and querying vector data. Vector buckets use dedicated APIs to manage vector data efficiently and reduce costs of upload, storing, and querying vector embeddings. Vector buckets provide the foundation for organizing your vector data into indexes, enabling you to perform similarity searches across large datasets while benefiting from the availability, durability, scalability, and cost-effectiveness of Amazon S3.

Vector buckets are optimized for long-term vector storage with sub-second search times. You can perform similarity queries on your vector data and optionally attach metadata to filter queries based on specific conditions such as dates, categories, or user preferences.

All data stored in vector buckets are always encrypted at rest. By default, vector buckets use SSE-S3 to encrypt vector data. You can choose to configure buckets to use server-side encryption with AWS Key Management Service (AWS KMS) keys (SSE-KMS) instead. The bucket encryption settings can’t be changed after a vector bucket is created, so it's important to choose the appropriate encryption method based on your security requirements and compliance needs.

### Dimension

Dimension relates to a numeric value between 1 and 4096 that determines how many numbers will be in each vector that's generated by your vector embedding model. Embedding models are specialized machine learning (ML) models that convert data (such as text or images) into numerical vectors. Embedding models typically produce outputs between 500-2000 dimensions, with each dimension being a floating-point number.

### Distance metric

You can configure the distance metric, either:
    - Cosine: which measures angular similarity 
    - or Euclidean: which measures straight-line distance 
as the distance metric to define how similarity between vectors is calculated during queries.

### Non-filterable metadata keys

Metadata keys allow you to attach additional information to your vectors as key-value pairs during storage and retrieval. By default, all metadata is filterable, so you can use it to filter query results. However, you can designate specific metadata keys as non-filterable when you want to store information with vectors without using it for filtering.

Unlike default metadata keys, these keys can't be used as query filters. Non-filterable metadata keys can be retrieved but can't be searched, queried, or filtered. You can only access it after finding the index.

Non-filterable metadata keys allow you to enrich vectors with additional context that you want to retrieve with search results but don't need for filtering. A common example of a non-filterable metadata key is when you embed text into vectors and want to include the original text itself as non-filterable metadata. This allows you to return the source text alongside vector search results without increasing your filterable metadata size limits.

### Encryption

You can configure the encryption type. You can use the bucket level encryption settings or override the encryption settings for the vector index. If you override the bucket-level settings, you have the option to specify encryption type for the vector index as Server-side encryption with AWS Key Management Service keys (SSE-KMS) or the Server-side encryption with Amazon S3 managed keys (SSE-S3). For more information about setting encryption configuration for vector buckets and indexes, see [Data protection and encryption in S3 Vectors](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-vectors-data-encryption.html).

Define a KMS-encrypted bucket:

```ts  fixture=default-bedrock
const vectorBucket = new genaicdk.s3vectors.VectorBucket(this, 'S3VectorBucket', {
    encryption: genaicdk.s3vectors.VectorBucketEncryption.KMS,
});
```

You can also supply your own key:

```ts  fixture=default-bedrock
const myKmsKey = new kms.Key(this, 'MyKey');

const vectorBucket = new genaicdk.s3vectors.VectorBucket(this, 'S3VectorBucket', {
    encryption: genaicdk.s3vectors.VectorBucketEncryption.KMS,
    encryptionKey: myKmsKey,
});
```

### Permissions

A bucket policy will be automatically created for the bucket upon the first call to addToResourcePolicy(statement):

```ts fixture=default-bedrock
const vectorBucket = new genaicdk.s3vectors.VectorBucket(this, 'S3VectorBucket');
const result = vectorBucket.addToResourcePolicy(
  new iam.PolicyStatement({
    actions: ['s3vectors:GetVector'],
    resources: [vectorBucket.vectorBucketArn],
    principals: [new iam.AccountRootPrincipal()],
  })
);
```

The bucket policy can be directly accessed after creation to add statements or adjust the removal policy.

```ts fixture=default-bedrock
const vectorBucket = new genaicdk.s3vectors.VectorBucket(this, 'S3VectorBucket');
vectorBucket.policy?.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);
```

Most of the time, you won't have to manipulate the bucket policy directly. Instead, buckets have "grant" methods called to give prepackaged sets of permissions to other resources. For example:

```ts fixture=default-bedrock
declare const myLambda: lambda.Function;

const vectorBucket = new genaicdk.s3vectors.VectorBucket(this, 'S3VectorBucket');
vectorBucket.grantRead(myLambda);
```

Will give the Lambda's execution role permissions to read from the bucket.

### Bucket deletion

When a bucket is removed from a stack (or the stack is deleted), the S3 bucket will be removed according to its removal policy (which by default will simply orphan the bucket and leave it in your AWS account). If the removal policy is set to RemovalPolicy.DESTROY, the bucket will be deleted as long as it does not contain any objects.

To override this and force all objects to get deleted during bucket deletion, enable the autoDeleteObjects option.

```ts fixture=default-bedrock
const vectorBucket = new genaicdk.s3vectors.VectorBucket(this, 'S3VectorBucket', {
    autoDeleteObjects: true,
    removalPolicy: cdk.RemovalPolicy.DESTROY,
});
```

## Vector index

Vector indexes are resources within vector buckets that store and organize vector data for efficient similarity search operations. When you create a vector index, you specify the distance metric (Cosine or Euclidean), the number of dimensions that a vector should have, and optionally a list of metadata fields that you want to exclude from filtering during similarity queries.

For more information about vector index limits per bucket, vector limits per index, and dimension limits per vector, see [Limitations and restrictions](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-vectors-limitations.html).

## Vector bucket policy

Vector bucket policies are resource-based policies that you attach directly to vector buckets to control access to the bucket and its contents. Bucket policies for vector buckets can grant permissions to principals from other AWS accounts, making them useful for cross-account access scenarios.